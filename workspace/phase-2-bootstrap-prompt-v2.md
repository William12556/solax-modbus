YOU ARE A CODE GENERATOR. OUTPUT ONLY CODE. NO EXPLANATIONS.

===== CRITICAL OUTPUT CONSTRAINTS =====

PROHIBITED:
- Explanatory text before code
- Explanatory text after code
- Phrases like "Here is the code"
- Phrases like "I have updated"
- Any narrative whatsoever

REQUIRED:
- Complete executable files only
- Start immediately with: # File: /path/to/file.py
- End with last line of code
- Nothing else

===== END CRITICAL OUTPUT CONSTRAINTS =====

TASK: Generate complete corrected file for /Users/williamwatson/Documents/GitHub/solax-modbus/src/solax_poll.py

CURRENT FILE (400+ lines):
```python
#!/usr/bin/env python3
"""
Solax X3 Hybrid 6.0-D Inverter Monitoring Script
Generated by Codestral for Cycle: solax-modbus-001
"""

import logging
import time
import sys
import argparse
from typing import Dict, Optional, Tuple, Any
from pymodbus.client import ModbusTcpClient
from pymodbus.exceptions import ModbusException

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('solax_poll.log')
    ]
)
logger = logging.getLogger(__name__)


class SolaxInverterClient:
    """
    Thread-safe client for Solax X3 Hybrid 6.0-D inverter communication.
    Implements Modbus TCP protocol with comprehensive error handling.
    """
    
    # INCORRECT REGISTER MAPPINGS - NEED CORRECTION
    REGISTER_MAPPINGS = {
        'grid_data': {
            'address': 0x006A,  # WRONG: should be 0x0000
            'count': 12,
            'description': 'Three-phase grid metrics'
        },
        'pv_voltage_current': {
            'address': 0x0003,  # WRONG: should be 0x0009
            'count': 4,
            'description': 'PV voltage and current for dual MPPT'
        },
        'pv_power': {
            'address': 0x000A,  # WRONG: should calculate from VÃ—I
            'count': 2,
            'description': 'PV power for dual MPPT'
        },
        'battery_data': {
            'address': 0x0014,  # CORRECT
            'count': 9,
            'description': 'Battery system metrics'
        },
        'feed_in_power': {
            'address': 0x0046,  # WRONG: should be 0x0020
            'count': 2,
            'description': 'Grid import/export power'
        },
        'energy_today': {
            'address': 0x0050,  # CORRECT
            'count': 1,
            'description': 'Daily energy generation'
        },
        'energy_total': {
            'address': 0x0052,  # CORRECT
            'count': 2,
            'description': 'Cumulative energy generation'
        },
        'inverter_status': {
            'address': 0x0008,  # WRONG: run_mode should be at 0x0047
            'count': 2,
            'description': 'Inverter temperature and run mode'
        }
    }
    
    RUN_MODES = {
        0: 'Waiting',
        1: 'Checking',
        2: 'Normal',
        3: 'Fault',
        4: 'Permanent Fault',
        5: 'Update',
        6: 'Off-grid Waiting',
        7: 'Off-grid',
        8: 'Self Testing',
        9: 'Idle',
        10: 'Standby'
    }
    
    def __init__(self, ip: str, port: int = 502, unit_id: int = 1):
        self.ip = ip
        self.port = port
        self.unit_id = unit_id
        self.client = None
        self.connection_attempts = 0
        self.max_retries = 3
        self.retry_delay = 1
        
    def connect(self) -> bool:
        for attempt in range(self.max_retries):
            try:
                logger.info(f"Attempting connection to {self.ip}:{self.port} (attempt {attempt + 1}/{self.max_retries})")
                self.client = ModbusTcpClient(self.ip, port=self.port)
                
                if self.client.connect():
                    logger.info(f"Successfully connected to inverter at {self.ip}:{self.port}")
                    self.connection_attempts = 0
                    return True
                else:
                    logger.warning(f"Connection attempt {attempt + 1} failed")
                    
            except Exception as e:
                logger.error(f"Connection error on attempt {attempt + 1}: {e}", exc_info=True)
            
            if attempt < self.max_retries - 1:
                delay = self.retry_delay * (2 ** attempt)
                logger.info(f"Waiting {delay} seconds before retry...")
                time.sleep(delay)
        
        logger.error(f"Failed to connect after {self.max_retries} attempts")
        return False
    
    def disconnect(self):
        if self.client:
            try:
                self.client.close()
                logger.info("Disconnected from inverter")
            except Exception as e:
                logger.error(f"Error during disconnect: {e}", exc_info=True)
    
    def read_registers(self, address: int, count: int, description: str) -> Optional[list]:
        try:
            result = self.client.read_input_registers(
                address=address,
                count=count,
                slave=self.unit_id
            )
            
            if not result.isError():
                logger.debug(f"Successfully read {description} from address 0x{address:04X}")
                return result.registers
            else:
                logger.error(f"Modbus error reading {description}: {result}")
                return None
                
        except ModbusException as e:
            logger.error(f"Modbus exception reading {description}: {e}", exc_info=True)
            return None
        except Exception as e:
            logger.error(f"Unexpected error reading {description}: {e}", exc_info=True)
            return None
    
    def poll_inverter(self) -> Dict[str, Any]:
        data = {}
        
        grid_regs = self.read_registers(**self.REGISTER_MAPPINGS['grid_data'])
        if grid_regs:
            data.update(self._process_grid_data(grid_regs))
        
        pv_vc_regs = self.read_registers(**self.REGISTER_MAPPINGS['pv_voltage_current'])
        pv_power_regs = self.read_registers(**self.REGISTER_MAPPINGS['pv_power'])
        if pv_vc_regs and pv_power_regs:
            data.update(self._process_pv_data(pv_vc_regs, pv_power_regs))
        
        battery_regs = self.read_registers(**self.REGISTER_MAPPINGS['battery_data'])
        if battery_regs:
            data.update(self._process_battery_data(battery_regs))
        
        feedin_regs = self.read_registers(**self.REGISTER_MAPPINGS['feed_in_power'])
        if feedin_regs:
            data['feed_in_power'] = self._to_signed_32(feedin_regs[0], feedin_regs[1])
        
        energy_today_regs = self.read_registers(**self.REGISTER_MAPPINGS['energy_today'])
        if energy_today_regs:
            data['energy_today'] = energy_today_regs[0] * 0.1
        
        energy_total_regs = self.read_registers(**self.REGISTER_MAPPINGS['energy_total'])
        if energy_total_regs:
            data['energy_total'] = self._to_unsigned_32(
                energy_total_regs[0], energy_total_regs[1]
            ) * 0.1
        
        status_regs = self.read_registers(**self.REGISTER_MAPPINGS['inverter_status'])
        if status_regs:
            data['inverter_temperature'] = self._to_signed(status_regs[0])
            data['run_mode'] = self.RUN_MODES.get(
                status_regs[1], 
                f'Unknown ({status_regs[1]})'
            )
        
        data['timestamp'] = time.strftime('%Y-%m-%d %H:%M:%S')
        return data
    
    def _process_grid_data(self, regs: list) -> Dict[str, float]:
        return {
            'grid_voltage_r': regs[0] * 0.1,
            'grid_current_r': self._to_signed(regs[1]) * 0.1,
            'grid_power_r': self._to_signed(regs[2]),
            'grid_frequency_r': regs[3] * 0.01,
            'grid_voltage_s': regs[4] * 0.1,
            'grid_current_s': self._to_signed(regs[5]) * 0.1,
            'grid_power_s': self._to_signed(regs[6]),
            'grid_frequency_s': regs[7] * 0.01,
            'grid_voltage_t': regs[8] * 0.1,
            'grid_current_t': self._to_signed(regs[9]) * 0.1,
            'grid_power_t': self._to_signed(regs[10]),
            'grid_frequency_t': regs[11] * 0.01,
        }
    
    def _process_pv_data(self, vc_regs: list, power_regs: list) -> Dict[str, float]:
        return {
            'pv1_voltage': vc_regs[0] * 0.1,
            'pv2_voltage': vc_regs[1] * 0.1,
            'pv1_current': vc_regs[2] * 0.1,
            'pv2_current': vc_regs[3] * 0.1,
            'pv1_power': power_regs[0],
            'pv2_power': power_regs[1],
        }
    
    def _process_battery_data(self, regs: list) -> Dict[str, Any]:
        return {
            'battery_voltage': self._to_signed(regs[0]) * 0.1,
            'battery_current': self._to_signed(regs[1]) * 0.1,
            'battery_power': self._to_signed(regs[2]),
            'battery_temperature': self._to_signed(regs[4]),
            'battery_soc': regs[8],
        }
    
    @staticmethod
    def _to_signed(value: int) -> int:
        return value if value < 32768 else value - 65536
    
    @staticmethod
    def _to_signed_32(low: int, high: int) -> int:
        value = (high << 16) | low
        return value if value < 2147483648 else value - 4294967296
    
    @staticmethod
    def _to_unsigned_32(low: int, high: int) -> int:
        return (high << 16) | low


class InverterDisplay:
    """Handles formatted display of inverter statistics."""
    
    @staticmethod
    def display_statistics(data: Dict[str, Any]):
        if not data:
            print("No data available")
            return
        
        print("\n" + "=" * 70)
        print("Solax X3 Hybrid 6.0-D Inverter Statistics")
        print(f"Timestamp: {data.get('timestamp', 'N/A')}")
        print("=" * 70)
        
        if 'run_mode' in data:
            print(f"\nâš¡ System Status: {data['run_mode']}")
        
        print("\nðŸ“Š Grid (Three-Phase AC)")
        print("-" * 70)
        if 'grid_voltage_r' in data:
            print(f"  R Phase: {data['grid_voltage_r']:6.1f}V  "
                  f"{data.get('grid_current_r', 0):6.1f}A  "
                  f"{data.get('grid_power_r', 0):7.0f}W")
            print(f"  S Phase: {data['grid_voltage_s']:6.1f}V  "
                  f"{data.get('grid_current_s', 0):6.1f}A  "
                  f"{data.get('grid_power_s', 0):7.0f}W")
            print(f"  T Phase: {data['grid_voltage_t']:6.1f}V  "
                  f"{data.get('grid_current_t', 0):6.1f}A  "
                  f"{data.get('grid_power_t', 0):7.0f}W")
            
            total_power = (
                data.get('grid_power_r', 0) + 
                data.get('grid_power_s', 0) + 
                data.get('grid_power_t', 0)
            )
            print(f"  Total:   {total_power:7.0f}W")
            print(f"  Frequency: {data.get('grid_frequency_r', 0):.2f}Hz")
        
        print("\nâ˜€ï¸  Solar PV Generation")
        print("-" * 70)
        if 'pv1_voltage' in data:
            print(f"  PV1: {data['pv1_voltage']:6.1f}V  "
                  f"{data.get('pv1_current', 0):5.1f}A  "
                  f"{data.get('pv1_power', 0):6.0f}W")
            print(f"  PV2: {data['pv2_voltage']:6.1f}V  "
                  f"{data.get('pv2_current', 0):5.1f}A  "
                  f"{data.get('pv2_power', 0):6.0f}W")
            
            total_pv = data.get('pv1_power', 0) + data.get('pv2_power', 0)
            print(f"  Total: {total_pv:6.0f}W")
        
        print("\nðŸ”‹ Battery System")
        print("-" * 70)
        if 'battery_voltage' in data:
            print(f"  Voltage: {data['battery_voltage']:.1f}V")
            
            current = data.get('battery_current', 0)
            if current > 0:
                direction = "Charging"
            elif current < 0:
                direction = "Discharging"
            else:
                direction = "Idle"
            print(f"  Current: {abs(current):.1f}A ({direction})")
            print(f"  Power: {data.get('battery_power', 0):.0f}W")
            print(f"  State of Charge: {data.get('battery_soc', 0)}%")
            print(f"  Temperature: {data.get('battery_temperature', 0)}Â°C")
        
        print("\nâš¡ Power Flow")
        print("-" * 70)
        if 'feed_in_power' in data:
            feedin = data['feed_in_power']
            if feedin > 0:
                print(f"  Grid Status: EXPORTING {feedin}W")
            elif feedin < 0:
                print(f"  Grid Status: IMPORTING {abs(feedin)}W")
            else:
                print(f"  Grid Status: BALANCED (0W)")
        
        print("\nðŸ“ˆ Energy Totals")
        print("-" * 70)
        if 'energy_today' in data:
            print(f"  Solar Generation Today: {data['energy_today']:.1f}kWh")
        if 'energy_total' in data:
            print(f"  Total Generation: {data['energy_total']:.1f}kWh")
        
        print("\nðŸ”§ Inverter")
        print("-" * 70)
        if 'inverter_temperature' in data:
            print(f"  Temperature: {data['inverter_temperature']}Â°C")
        
        print("=" * 70 + "\n")


def main():
    parser = argparse.ArgumentParser(
        description='Solax X3 Hybrid 6.0-D Inverter Monitoring via Modbus TCP',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s 192.168.1.100
  %(prog)s 192.168.1.100 --interval 10
  %(prog)s 192.168.1.100 --port 1502
  %(prog)s 192.168.1.100 --debug
        """
    )
    
    parser.add_argument('ip', help='IP address of the inverter (WiFi/LAN dongle)')
    parser.add_argument('--port', type=int, default=502, help='Modbus TCP port (default: 502)')
    parser.add_argument('--unit-id', type=int, default=1, help='Modbus unit ID (default: 1)')
    parser.add_argument('--interval', type=int, default=5, help='Polling interval in seconds (minimum: 1, default: 5)')
    parser.add_argument('--debug', action='store_true', help='Enable debug logging')
    
    args = parser.parse_args()
    
    if args.debug:
        logging.getLogger().setLevel(logging.DEBUG)
    
    poll_interval = max(args.interval, 1)
    if args.interval < 1:
        logger.warning(f"Interval {args.interval}s below minimum, using 1s")
    
    print(f"\nSolax X3 Hybrid Inverter - Modbus TCP Monitor")
    print(f"Connecting to {args.ip}:{args.port}")
    print(f"Polling interval: {poll_interval} seconds")
    print(f"Press Ctrl+C to stop\n")
    print("-" * 70)
    
    client = SolaxInverterClient(args.ip, args.port, args.unit_id)
    display = InverterDisplay()
    
    try:
        while True:
            try:
                if not client.client or not client.client.is_socket_open():
                    if not client.connect():
                        logger.error("Failed to establish connection, retrying...")
                        time.sleep(poll_interval)
                        continue
                
                data = client.poll_inverter()
                display.display_statistics(data)
                
                time.sleep(poll_interval)
                
            except KeyboardInterrupt:
                raise
            except Exception as e:
                logger.error(f"Error in monitoring loop: {e}", exc_info=True)
                time.sleep(poll_interval)
                
    except KeyboardInterrupt:
        print("\n\nâš ï¸  Shutdown signal received...")
    finally:
        client.disconnect()
        print("âœ… Monitoring stopped")
        logger.info("Application terminated")


if __name__ == "__main__":
    main()
```

CORRECTIONS REQUIRED:

1. REGISTER_MAPPINGS dictionary:
   - 'grid_data': address=0x0000, count=9
   - 'pv_voltage_current': address=0x0009, count=4
   - REMOVE 'pv_power' entry entirely
   - ADD 'grid_frequency': address=0x0009, count=1
   - 'feed_in_power': address=0x0020, count=2
   - ADD 'run_mode': address=0x0047, count=1
   - ADD 'inverter_temperature': address=0x0008, count=1

2. poll_inverter() method:
   - Remove pv_power_regs read
   - Add grid_frequency_regs read
   - Add run_mode_regs read
   - Change inverter_status to inverter_temperature (1 register only)

3. _process_grid_data():
   - Process 9 registers not 12
   - Remove per-phase frequency
   - Single frequency value for all phases

4. _process_pv_data():
   - Remove power_regs parameter
   - Calculate: pv1_power = pv1_voltage * pv1_current
   - Calculate: pv2_power = pv2_voltage * pv2_current

OUTPUT COMPLETE CORRECTED FILE NOW. START WITH: # File: /Users/williamwatson/Documents/GitHub/solax-modbus/src/solax_poll.py
