GENERATE COMPLETE CODE:

CODESTRAL IMPLEMENTATION REQUEST
CYCLE: solax-modbus-phase-2
PROJECT: solax-modbus
TARGET REPOSITORY: /Users/williamwatson/Documents/GitHub/solax-modbus/
TASK TYPE: Code Correction
CONTEXT: Phase 1 implementation contains incorrect Modbus register addresses preventing functional inverter communication. Phase 2 corrects register mappings to align with verified design specification.

EXECUTION DIRECTIVE:
Write all code to the target repository specified above.
Do not write code to the framework repository.
Reference framework specifications, templates, and patterns as guidance.

===== OUTPUT FORMAT REQUIREMENTS =====

CRITICAL: Generate complete, executable code only. Do not provide explanations, narratives, or descriptions unless explicitly requested.

EXPECTED OUTPUT STRUCTURE:

1. PRIMARY DELIVERABLE: Complete source code file(s)
   - File path comment at top: # File: /path/to/file.py
   - All imports
   - All class definitions
   - All function implementations
   - All constants and configuration
   - No placeholder comments like "# implementation here"
   - No abbreviated sections with "..."

2. SUPPORTING DELIVERABLES:
   - Test file: Complete test suite with all test methods
   - Verification document: Markdown file documenting changes

3. DEPENDENCY SPECIFICATION:
   - No changes to requirements.txt

FORMAT VALIDATION CHECKLIST:
- [ ] All functions contain complete implementations
- [ ] No explanatory text outside code blocks
- [ ] No "TODO" or "PLACEHOLDER" comments
- [ ] All imports present and correct
- [ ] File structure matches specification
- [ ] Docstrings present for public interfaces

===== END OUTPUT FORMAT REQUIREMENTS =====

===== STATELESS EXECUTION NOTICE =====

CRITICAL CONSTRAINT: This API has zero memory of previous requests.

This prompt is COMPLETELY SELF-CONTAINED. All necessary information is included below. This is your FIRST and ONLY interaction with this task.

===== END STATELESS EXECUTION NOTICE =====

===== CURRENT IMPLEMENTATION =====

File: /Users/williamwatson/Documents/GitHub/solax-modbus/src/solax_poll.py

The current implementation reads from incorrect register addresses. Here is the COMPLETE current implementation that needs correction:

```python
#!/usr/bin/env python3
"""
Solax X3 Hybrid 6.0-D Inverter Monitoring Script
Generated by Codestral for Cycle: solax-modbus-001
"""

import logging
import time
import sys
import argparse
from typing import Dict, Optional, Tuple, Any
from pymodbus.client import ModbusTcpClient
from pymodbus.exceptions import ModbusException

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('solax_poll.log')
    ]
)
logger = logging.getLogger(__name__)


class SolaxInverterClient:
    """
    Thread-safe client for Solax X3 Hybrid 6.0-D inverter communication.
    Implements Modbus TCP protocol with comprehensive error handling.
    """
    
    # INCORRECT REGISTER MAPPINGS - NEED CORRECTION
    REGISTER_MAPPINGS = {
        'grid_data': {
            'address': 0x006A,  # WRONG: should be 0x0000
            'count': 12,
            'description': 'Three-phase grid metrics'
        },
        'pv_voltage_current': {
            'address': 0x0003,  # WRONG: should be 0x0009
            'count': 4,
            'description': 'PV voltage and current for dual MPPT'
        },
        'pv_power': {
            'address': 0x000A,  # WRONG: should calculate from VÃ—I
            'count': 2,
            'description': 'PV power for dual MPPT'
        },
        'battery_data': {
            'address': 0x0014,  # CORRECT
            'count': 9,
            'description': 'Battery system metrics'
        },
        'feed_in_power': {
            'address': 0x0046,  # WRONG: should be 0x0020
            'count': 2,
            'description': 'Grid import/export power'
        },
        'energy_today': {
            'address': 0x0050,  # CORRECT
            'count': 1,
            'description': 'Daily energy generation'
        },
        'energy_total': {
            'address': 0x0052,  # CORRECT
            'count': 2,
            'description': 'Cumulative energy generation'
        },
        'inverter_status': {
            'address': 0x0008,  # WRONG: run_mode should be at 0x0047
            'count': 2,
            'description': 'Inverter temperature and run mode'
        }
    }
    
    RUN_MODES = {
        0: 'Waiting',
        1: 'Checking',
        2: 'Normal',
        3: 'Fault',
        4: 'Permanent Fault',
        5: 'Update',
        6: 'Off-grid Waiting',
        7: 'Off-grid',
        8: 'Self Testing',
        9: 'Idle',
        10: 'Standby'
    }
    
    def __init__(self, ip: str, port: int = 502, unit_id: int = 1):
        self.ip = ip
        self.port = port
        self.unit_id = unit_id
        self.client = None
        self.connection_attempts = 0
        self.max_retries = 3
        self.retry_delay = 1
        
    def connect(self) -> bool:
        for attempt in range(self.max_retries):
            try:
                logger.info(f"Attempting connection to {self.ip}:{self.port} (attempt {attempt + 1}/{self.max_retries})")
                self.client = ModbusTcpClient(self.ip, port=self.port)
                
                if self.client.connect():
                    logger.info(f"Successfully connected to inverter at {self.ip}:{self.port}")
                    self.connection_attempts = 0
                    return True
                else:
                    logger.warning(f"Connection attempt {attempt + 1} failed")
                    
            except Exception as e:
                logger.error(f"Connection error on attempt {attempt + 1}: {e}", exc_info=True)
            
            if attempt < self.max_retries - 1:
                delay = self.retry_delay * (2 ** attempt)
                logger.info(f"Waiting {delay} seconds before retry...")
                time.sleep(delay)
        
        logger.error(f"Failed to connect after {self.max_retries} attempts")
        return False
    
    def disconnect(self):
        if self.client:
            try:
                self.client.close()
                logger.info("Disconnected from inverter")
            except Exception as e:
                logger.error(f"Error during disconnect: {e}", exc_info=True)
    
    def read_registers(self, address: int, count: int, description: str) -> Optional[list]:
        try:
            result = self.client.read_input_registers(
                address=address,
                count=count,
                slave=self.unit_id
            )
            
            if not result.isError():
                logger.debug(f"Successfully read {description} from address 0x{address:04X}")
                return result.registers
            else:
                logger.error(f"Modbus error reading {description}: {result}")
                return None
                
        except ModbusException as e:
            logger.error(f"Modbus exception reading {description}: {e}", exc_info=True)
            return None
        except Exception as e:
            logger.error(f"Unexpected error reading {description}: {e}", exc_info=True)
            return None
    
    def poll_inverter(self) -> Dict[str, Any]:
        data = {}
        
        grid_regs = self.read_registers(**self.REGISTER_MAPPINGS['grid_data'])
        if grid_regs:
            data.update(self._process_grid_data(grid_regs))
        
        pv_vc_regs = self.read_registers(**self.REGISTER_MAPPINGS['pv_voltage_current'])
        pv_power_regs = self.read_registers(**self.REGISTER_MAPPINGS['pv_power'])
        if pv_vc_regs and pv_power_regs:
            data.update(self._process_pv_data(pv_vc_regs, pv_power_regs))
        
        battery_regs = self.read_registers(**self.REGISTER_MAPPINGS['battery_data'])
        if battery_regs:
            data.update(self._process_battery_data(battery_regs))
        
        feedin_regs = self.read_registers(**self.REGISTER_MAPPINGS['feed_in_power'])
        if feedin_regs:
            data['feed_in_power'] = self._to_signed_32(feedin_regs[0], feedin_regs[1])
        
        energy_today_regs = self.read_registers(**self.REGISTER_MAPPINGS['energy_today'])
        if energy_today_regs:
            data['energy_today'] = energy_today_regs[0] * 0.1
        
        energy_total_regs = self.read_registers(**self.REGISTER_MAPPINGS['energy_total'])
        if energy_total_regs:
            data['energy_total'] = self._to_unsigned_32(
                energy_total_regs[0], energy_total_regs[1]
            ) * 0.1
        
        status_regs = self.read_registers(**self.REGISTER_MAPPINGS['inverter_status'])
        if status_regs:
            data['inverter_temperature'] = self._to_signed(status_regs[0])
            data['run_mode'] = self.RUN_MODES.get(
                status_regs[1], 
                f'Unknown ({status_regs[1]})'
            )
        
        data['timestamp'] = time.strftime('%Y-%m-%d %H:%M:%S')
        return data
    
    def _process_grid_data(self, regs: list) -> Dict[str, float]:
        return {
            'grid_voltage_r': regs[0] * 0.1,
            'grid_current_r': self._to_signed(regs[1]) * 0.1,
            'grid_power_r': self._to_signed(regs[2]),
            'grid_frequency_r': regs[3] * 0.01,
            'grid_voltage_s': regs[4] * 0.1,
            'grid_current_s': self._to_signed(regs[5]) * 0.1,
            'grid_power_s': self._to_signed(regs[6]),
            'grid_frequency_s': regs[7] * 0.01,
            'grid_voltage_t': regs[8] * 0.1,
            'grid_current_t': self._to_signed(regs[9]) * 0.1,
            'grid_power_t': self._to_signed(regs[10]),
            'grid_frequency_t': regs[11] * 0.01,
        }
    
    def _process_pv_data(self, vc_regs: list, power_regs: list) -> Dict[str, float]:
        return {
            'pv1_voltage': vc_regs[0] * 0.1,
            'pv2_voltage': vc_regs[1] * 0.1,
            'pv1_current': vc_regs[2] * 0.1,
            'pv2_current': vc_regs[3] * 0.1,
            'pv1_power': power_regs[0],
            'pv2_power': power_regs[1],
        }
    
    def _process_battery_data(self, regs: list) -> Dict[str, Any]:
        return {
            'battery_voltage': self._to_signed(regs[0]) * 0.1,
            'battery_current': self._to_signed(regs[1]) * 0.1,
            'battery_power': self._to_signed(regs[2]),
            'battery_temperature': self._to_signed(regs[4]),
            'battery_soc': regs[8],
        }
    
    @staticmethod
    def _to_signed(value: int) -> int:
        return value if value < 32768 else value - 65536
    
    @staticmethod
    def _to_signed_32(low: int, high: int) -> int:
        value = (high << 16) | low
        return value if value < 2147483648 else value - 4294967296
    
    @staticmethod
    def _to_unsigned_32(low: int, high: int) -> int:
        return (high << 16) | low


class InverterDisplay:
    """Handles formatted display of inverter statistics."""
    
    @staticmethod
    def display_statistics(data: Dict[str, Any]):
        if not data:
            print("No data available")
            return
        
        print("\n" + "=" * 70)
        print("Solax X3 Hybrid 6.0-D Inverter Statistics")
        print(f"Timestamp: {data.get('timestamp', 'N/A')}")
        print("=" * 70)
        
        if 'run_mode' in data:
            print(f"\nâš¡ System Status: {data['run_mode']}")
        
        print("\nðŸ“Š Grid (Three-Phase AC)")
        print("-" * 70)
        if 'grid_voltage_r' in data:
            print(f"  R Phase: {data['grid_voltage_r']:6.1f}V  "
                  f"{data.get('grid_current_r', 0):6.1f}A  "
                  f"{data.get('grid_power_r', 0):7.0f}W")
            print(f"  S Phase: {data['grid_voltage_s']:6.1f}V  "
                  f"{data.get('grid_current_s', 0):6.1f}A  "
                  f"{data.get('grid_power_s', 0):7.0f}W")
            print(f"  T Phase: {data['grid_voltage_t']:6.1f}V  "
                  f"{data.get('grid_current_t', 0):6.1f}A  "
                  f"{data.get('grid_power_t', 0):7.0f}W")
            
            total_power = (
                data.get('grid_power_r', 0) + 
                data.get('grid_power_s', 0) + 
                data.get('grid_power_t', 0)
            )
            print(f"  Total:   {total_power:7.0f}W")
            print(f"  Frequency: {data.get('grid_frequency_r', 0):.2f}Hz")
        
        print("\nâ˜€ï¸  Solar PV Generation")
        print("-" * 70)
        if 'pv1_voltage' in data:
            print(f"  PV1: {data['pv1_voltage']:6.1f}V  "
                  f"{data.get('pv1_current', 0):5.1f}A  "
                  f"{data.get('pv1_power', 0):6.0f}W")
            print(f"  PV2: {data['pv2_voltage']:6.1f}V  "
                  f"{data.get('pv2_current', 0):5.1f}A  "
                  f"{data.get('pv2_power', 0):6.0f}W")
            
            total_pv = data.get('pv1_power', 0) + data.get('pv2_power', 0)
            print(f"  Total: {total_pv:6.0f}W")
        
        print("\nðŸ”‹ Battery System")
        print("-" * 70)
        if 'battery_voltage' in data:
            print(f"  Voltage: {data['battery_voltage']:.1f}V")
            
            current = data.get('battery_current', 0)
            if current > 0:
                direction = "Charging"
            elif current < 0:
                direction = "Discharging"
            else:
                direction = "Idle"
            print(f"  Current: {abs(current):.1f}A ({direction})")
            print(f"  Power: {data.get('battery_power', 0):.0f}W")
            print(f"  State of Charge: {data.get('battery_soc', 0)}%")
            print(f"  Temperature: {data.get('battery_temperature', 0)}Â°C")
        
        print("\nâš¡ Power Flow")
        print("-" * 70)
        if 'feed_in_power' in data:
            feedin = data['feed_in_power']
            if feedin > 0:
                print(f"  Grid Status: EXPORTING {feedin}W")
            elif feedin < 0:
                print(f"  Grid Status: IMPORTING {abs(feedin)}W")
            else:
                print(f"  Grid Status: BALANCED (0W)")
        
        print("\nðŸ“ˆ Energy Totals")
        print("-" * 70)
        if 'energy_today' in data:
            print(f"  Solar Generation Today: {data['energy_today']:.1f}kWh")
        if 'energy_total' in data:
            print(f"  Total Generation: {data['energy_total']:.1f}kWh")
        
        print("\nðŸ”§ Inverter")
        print("-" * 70)
        if 'inverter_temperature' in data:
            print(f"  Temperature: {data['inverter_temperature']}Â°C")
        
        print("=" * 70 + "\n")


def main():
    parser = argparse.ArgumentParser(
        description='Solax X3 Hybrid 6.0-D Inverter Monitoring via Modbus TCP',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s 192.168.1.100
  %(prog)s 192.168.1.100 --interval 10
  %(prog)s 192.168.1.100 --port 1502
  %(prog)s 192.168.1.100 --debug
        """
    )
    
    parser.add_argument('ip', help='IP address of the inverter (WiFi/LAN dongle)')
    parser.add_argument('--port', type=int, default=502, help='Modbus TCP port (default: 502)')
    parser.add_argument('--unit-id', type=int, default=1, help='Modbus unit ID (default: 1)')
    parser.add_argument('--interval', type=int, default=5, help='Polling interval in seconds (minimum: 1, default: 5)')
    parser.add_argument('--debug', action='store_true', help='Enable debug logging')
    
    args = parser.parse_args()
    
    if args.debug:
        logging.getLogger().setLevel(logging.DEBUG)
    
    poll_interval = max(args.interval, 1)
    if args.interval < 1:
        logger.warning(f"Interval {args.interval}s below minimum, using 1s")
    
    print(f"\nSolax X3 Hybrid Inverter - Modbus TCP Monitor")
    print(f"Connecting to {args.ip}:{args.port}")
    print(f"Polling interval: {poll_interval} seconds")
    print(f"Press Ctrl+C to stop\n")
    print("-" * 70)
    
    client = SolaxInverterClient(args.ip, args.port, args.unit_id)
    display = InverterDisplay()
    
    try:
        while True:
            try:
                if not client.client or not client.client.is_socket_open():
                    if not client.connect():
                        logger.error("Failed to establish connection, retrying...")
                        time.sleep(poll_interval)
                        continue
                
                data = client.poll_inverter()
                display.display_statistics(data)
                
                time.sleep(poll_interval)
                
            except KeyboardInterrupt:
                raise
            except Exception as e:
                logger.error(f"Error in monitoring loop: {e}", exc_info=True)
                time.sleep(poll_interval)
                
    except KeyboardInterrupt:
        print("\n\nâš ï¸  Shutdown signal received...")
    finally:
        client.disconnect()
        print("âœ… Monitoring stopped")
        logger.info("Application terminated")


if __name__ == "__main__":
    main()
```

===== END CURRENT IMPLEMENTATION =====

===== REGISTER CORRECTION SPECIFICATION =====

CORRECT REGISTER ADDRESSES per Design Specification Section 6.1:

Grid Data (Three-Phase):
- Address: 0x0000 (not 0x006A)
- Count: 9 registers (not 12)
- Layout:
  - 0x0000: Grid Voltage R (uint16, scale 0.1)
  - 0x0001: Grid Voltage S (uint16, scale 0.1)
  - 0x0002: Grid Voltage T (uint16, scale 0.1)
  - 0x0003: Grid Current R (uint16, scale 0.1)
  - 0x0004: Grid Current S (uint16, scale 0.1)
  - 0x0005: Grid Current T (uint16, scale 0.1)
  - 0x0006: Grid Power R (int16, scale 1)
  - 0x0007: Grid Power S (int16, scale 1)
  - 0x0008: Grid Power T (int16, scale 1)

Grid Frequency:
- Address: 0x0009 (single register for all phases)
- Scale: 0.01 Hz

PV Data:
- Address: 0x0009 (PV1 Voltage, uint16, scale 0.1)
- Address: 0x000A (PV2 Voltage, uint16, scale 0.1)
- Address: 0x000B (PV1 Current, uint16, scale 0.1)
- Address: 0x000C (PV2 Current, uint16, scale 0.1)
- PV Power: CALCULATE from voltage Ã— current (do not read from registers)

Battery Data:
- Address: 0x0014 (CORRECT - no change)
- Count: 9 registers
- Layout remains the same

Feed-in Power:
- Address: 0x0020 (not 0x0046)
- Count: 2 registers (signed 32-bit)

Inverter Temperature:
- Address: 0x0008 (CORRECT - no change)
- Count: 1 register

Run Mode:
- Address: 0x0047 (not part of 0x0008 read)
- Count: 1 register
- Enumeration values remain the same

Energy Today:
- Address: 0x0050 (CORRECT - no change)

Energy Total:
- Address: 0x0052 (CORRECT - no change)

===== END REGISTER CORRECTION SPECIFICATION =====

===== IMPLEMENTATION REQUIREMENTS =====

MODIFICATIONS REQUIRED:

1. Update REGISTER_MAPPINGS dictionary:
   - Change 'grid_data' address to 0x0000, count to 9
   - Change 'pv_voltage_current' address to 0x0009, count to 4
   - REMOVE 'pv_power' entry (will calculate instead)
   - Add 'grid_frequency' entry: address 0x0009, count 1
   - Change 'feed_in_power' address to 0x0020
   - Add 'run_mode' entry: address 0x0047, count 1
   - Keep battery_data, energy_today, energy_total unchanged

2. Modify poll_inverter() method:
   - Read grid_data from corrected address
   - Read grid_frequency separately (single register)
   - Read pv_voltage_current from corrected address
   - REMOVE pv_power register read
   - Read run_mode separately from 0x0047
   - Keep inverter temperature read at 0x0008 (1 register only)

3. Modify _process_grid_data() method:
   - Process only 9 registers (not 12)
   - Remove per-phase frequency processing
   - Return single frequency value for all phases

4. Modify _process_pv_data() method:
   - Accept only voltage/current registers (no power registers)
   - CALCULATE pv1_power = pv1_voltage * pv1_current
   - CALCULATE pv2_power = pv2_voltage * pv2_current
   - Return calculated power values

5. Preserve all other functionality:
   - Error handling unchanged
   - Logging unchanged
   - Display formatting unchanged
   - Connection management unchanged
   - Retry logic unchanged

QUALITY REQUIREMENTS:

- All register addresses match specification exactly
- PV power calculation: power = voltage * current
- Grid frequency: single value applied to display
- No functional regressions
- Error handling preserved
- Logging behavior unchanged
- Display output format unchanged

===== END IMPLEMENTATION REQUIREMENTS =====

===== TEST REQUIREMENTS =====

Update tests/test_solax_poll.py to:

1. Mock corrected register addresses:
   - Grid data at 0x0000
   - Grid frequency at 0x0009
   - PV voltage/current at 0x0009
   - Feed-in power at 0x0020
   - Run mode at 0x0047

2. Test PV power calculation:
   - Verify power = voltage Ã— current
   - Test with various voltage/current values
   - Verify rounding/precision

3. Test grid frequency handling:
   - Verify single register read
   - Verify frequency appears in display output

4. Verify data type conversions:
   - Test signed/unsigned conversions
   - Test 32-bit register combinations
   - Test scaling factors

===== END TEST REQUIREMENTS =====

===== SUCCESS CRITERIA =====

FUNCTIONAL VALIDATION:
- All register reads occur at corrected addresses
- PV power calculated correctly (within 1W of VÃ—I)
- Grid frequency reads single register
- Display output shows logical values
- No ModbusException errors

TECHNICAL VALIDATION:
- Unit tests pass with updated mocks
- Test coverage maintained at >70%
- Code formatting preserved (PEP 8)
- No regressions in error handling

CODE QUALITY:
- Docstrings preserved
- Inline comments preserved
- Class structure unchanged
- Method signatures unchanged
- Variable naming unchanged

===== END SUCCESS CRITERIA =====

===== DELIVERABLES =====

Generate the following complete files:

1. /Users/williamwatson/Documents/GitHub/solax-modbus/src/solax_poll.py
   - Complete corrected implementation
   - All register addresses updated
   - PV power calculation implemented
   - Grid frequency single-register handling
   - All other functionality preserved

2. /Users/williamwatson/Documents/GitHub/solax-modbus/tests/test_solax_poll.py
   - Complete updated test suite
   - Updated mock addresses
   - PV power calculation tests
   - Grid frequency tests
   - All existing tests updated

3. /Users/williamwatson/Documents/GitHub/solax-modbus/docs/verification/phase-2-changes.md
   - List of register address changes
   - Verification of alignment with specification
   - Summary of PV power calculation change
   - Summary of grid frequency change

===== END DELIVERABLES =====

PROJECT STANDARDS COMPLIANCE:
- Thread safety maintained for concurrent operations
- Comprehensive logging with traceback preserved
- Cross-platform compatibility preserved
- Professional documentation maintained
- PEP 8 code formatting preserved

ARCHITECTURAL CONTEXT:
- SolaxInverterClient: Protocol interface layer
- InverterDisplay: Presentation layer
- Clean separation of concerns maintained
- No architectural changes permitted

CONSTRAINTS:
- Python 3.11+ compatibility required
- pymodbus 3.5.0+ API unchanged
- No new dependencies
- Preserve existing class structure
- Preserve existing method signatures
- Preserve existing error handling patterns

DECISION BOUNDARIES:
Autonomous Authority:
- Register address corrections per specification
- PV power calculation implementation
- Grid frequency single-register handling
- Test mock updates

Mandatory Escalation:
- Any ambiguity in register specifications
- Any functional behavior changes beyond corrections
- Any architectural modifications
- Any new dependencies

EXECUTION SCOPE:
In Scope:
- src/solax_poll.py register address corrections
- tests/test_solax_poll.py test updates
- docs/verification/phase-2-changes.md documentation

Out of Scope:
- New functionality beyond corrections
- Database integration
- Alert system
- Multi-inverter support
- Configuration system
- API development

PROTOCOL COMPLIANCE:
- Protocol 000: Framework Constitution adherence
- Protocol 002: Execution boundaries respect
- Protocol 003: Documentation standards compliance
- Protocol 005: Logging standards preserved

===== EXECUTION DIRECTIVE =====
Generate complete code implementing the register address corrections.
Include complete test suite with updated mocks.
Include verification document.
This is a self-contained request requiring no external context.
Begin with corrected solax_poll.py file.
===== END DIRECTIVE =====

TEMPLATE: Bootstrap_Prompt_v1.2
