#!/usr/bin/env python3
"""
Solax X3 Hybrid 6.0-D Inverter Monitoring Script
Generated by Codestral for Cycle: solax-modbus-001
"""

import logging
import time
import sys
import argparse
from typing import Dict, Optional, Tuple, Any
from pymodbus.client import ModbusTcpClient
from pymodbus.exceptions import ModbusException

# Configure comprehensive logging with traceback per Protocol 005
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('/tmp/solax_poll.log')
    ]
)
logger = logging.getLogger(__name__)


class SolaxInverterClient:
    """
    Thread-safe client for Solax X3 Hybrid 6.0-D inverter communication.
    Implements Modbus TCP protocol with comprehensive error handling.
    """
    
    # Register mappings as per specification
    REGISTER_MAPPINGS = {
        'grid_data': {
            'address': 0x006A,
            'count': 12,
            'description': 'Three-phase grid metrics'
        },
        'pv_voltage_current': {
            'address': 0x0003,
            'count': 4,
            'description': 'PV voltage and current for dual MPPT'
        },
        'pv_power': {
            'address': 0x000A,
            'count': 2,
            'description': 'PV power for dual MPPT'
        },
        'battery_data': {
            'address': 0x0014,
            'count': 9,
            'description': 'Battery system metrics'
        },
        'feed_in_power': {
            'address': 0x0046,
            'count': 2,
            'description': 'Grid import/export power'
        },
        'energy_today': {
            'address': 0x0050,
            'count': 1,
            'description': 'Daily energy generation'
        },
        'energy_total': {
            'address': 0x0052,
            'count': 2,
            'description': 'Cumulative energy generation'
        },
        'inverter_status': {
            'address': 0x0008,
            'count': 2,
            'description': 'Inverter temperature and run mode'
        }
    }
    
    # Run mode mapping
    RUN_MODES = {
        0: 'Waiting',
        1: 'Checking',
        2: 'Normal',
        3: 'Fault',
        4: 'Permanent Fault',
        5: 'Update',
        6: 'Off-grid Waiting',
        7: 'Off-grid',
        8: 'Self Testing',
        9: 'Idle',
        10: 'Standby'
    }
    
    def __init__(self, ip: str, port: int = 502, unit_id: int = 1):
        """
        Initialize Modbus TCP client.
        
        Args:
            ip: IP address of inverter
            port: Modbus TCP port (default 502)
            unit_id: Modbus unit identifier (default 1)
        """
        self.ip = ip
        self.port = port
        self.unit_id = unit_id
        self.client = None
        self.connection_attempts = 0
        self.max_retries = 3
        self.retry_delay = 1  # Initial delay in seconds
        
    def connect(self) -> bool:
        """
        Establish connection with exponential backoff retry logic.
        
        Returns:
            True if connected successfully, False otherwise
        """
        for attempt in range(self.max_retries):
            try:
                logger.info(f"Attempting connection to {self.ip}:{self.port} (attempt {attempt + 1}/{self.max_retries})")
                self.client = ModbusTcpClient(self.ip, port=self.port)
                
                if self.client.connect():
                    logger.info(f"Successfully connected to inverter at {self.ip}:{self.port}")
                    self.connection_attempts = 0
                    return True
                else:
                    logger.warning(f"Connection attempt {attempt + 1} failed")
                    
            except Exception as e:
                logger.error(f"Connection error on attempt {attempt + 1}: {e}", exc_info=True)
            
            # Exponential backoff
            if attempt < self.max_retries - 1:
                delay = self.retry_delay * (2 ** attempt)
                logger.info(f"Waiting {delay} seconds before retry...")
                time.sleep(delay)
        
        logger.error(f"Failed to connect after {self.max_retries} attempts")
        return False
    
    def disconnect(self):
        """Safely disconnect from inverter."""
        if self.client:
            try:
                self.client.close()
                logger.info("Disconnected from inverter")
            except Exception as e:
                logger.error(f"Error during disconnect: {e}", exc_info=True)
    
    def read_registers(self, address: int, count: int, description: str) -> Optional[list]:
        """
        Read input registers with error handling.
        
        Args:
            address: Starting register address
            count: Number of registers to read
            description: Description for logging
            
        Returns:
            List of register values or None on error
        """
        try:
            result = self.client.read_input_registers(
                address=address,
                count=count,
                device_id=self.unit_id
            )
            
            if not result.isError():
                logger.debug(f"Successfully read {description} from address 0x{address:04X}")
                return result.registers
            else:
                logger.error(f"Modbus error reading {description}: {result}")
                return None
                
        except ModbusException as e:
            logger.error(f"Modbus exception reading {description}: {e}", exc_info=True)
            return None
        except Exception as e:
            logger.error(f"Unexpected error reading {description}: {e}", exc_info=True)
            return None
    
    def poll_inverter(self) -> Dict[str, Any]:
        """
        Poll all inverter registers and return processed data.
        
        Returns:
            Dictionary containing all inverter metrics
        """
        data = {}
        
        # Read grid data (three-phase)
        grid_regs = self.read_registers(
            **self.REGISTER_MAPPINGS['grid_data']
        )
        if grid_regs:
            data.update(self._process_grid_data(grid_regs))
        
        # Read PV data
        pv_vc_regs = self.read_registers(
            **self.REGISTER_MAPPINGS['pv_voltage_current']
        )
        pv_power_regs = self.read_registers(
            **self.REGISTER_MAPPINGS['pv_power']
        )
        if pv_vc_regs and pv_power_regs:
            data.update(self._process_pv_data(pv_vc_regs, pv_power_regs))
        
        # Read battery data
        battery_regs = self.read_registers(
            **self.REGISTER_MAPPINGS['battery_data']
        )
        if battery_regs:
            data.update(self._process_battery_data(battery_regs))
        
        # Read feed-in power
        feedin_regs = self.read_registers(
            **self.REGISTER_MAPPINGS['feed_in_power']
        )
        if feedin_regs:
            data['feed_in_power'] = self._to_signed_32(feedin_regs[0], feedin_regs[1])
        
        # Read energy totals
        energy_today_regs = self.read_registers(
            **self.REGISTER_MAPPINGS['energy_today']
        )
        if energy_today_regs:
            data['energy_today'] = energy_today_regs[0] * 0.1
        
        energy_total_regs = self.read_registers(
            **self.REGISTER_MAPPINGS['energy_total']
        )
        if energy_total_regs:
            data['energy_total'] = self._to_unsigned_32(
                energy_total_regs[0], energy_total_regs[1]
            ) * 0.1
        
        # Read inverter status
        status_regs = self.read_registers(
            **self.REGISTER_MAPPINGS['inverter_status']
        )
        if status_regs:
            data['inverter_temperature'] = self._to_signed(status_regs[0])
            data['run_mode'] = self.RUN_MODES.get(
                status_regs[1], 
                f'Unknown ({status_regs[1]})'
            )
        
        data['timestamp'] = time.strftime('%Y-%m-%d %H:%M:%S')
        return data
    
    def _process_grid_data(self, regs: list) -> Dict[str, float]:
        """Process three-phase grid data."""
        return {
            'grid_voltage_r': regs[0] * 0.1,
            'grid_current_r': self._to_signed(regs[1]) * 0.1,
            'grid_power_r': self._to_signed(regs[2]),
            'grid_frequency_r': regs[3] * 0.01,
            'grid_voltage_s': regs[4] * 0.1,
            'grid_current_s': self._to_signed(regs[5]) * 0.1,
            'grid_power_s': self._to_signed(regs[6]),
            'grid_frequency_s': regs[7] * 0.01,
            'grid_voltage_t': regs[8] * 0.1,
            'grid_current_t': self._to_signed(regs[9]) * 0.1,
            'grid_power_t': self._to_signed(regs[10]),
            'grid_frequency_t': regs[11] * 0.01,
        }
    
    def _process_pv_data(self, vc_regs: list, power_regs: list) -> Dict[str, float]:
        """Process PV generation data."""
        return {
            'pv1_voltage': vc_regs[0] * 0.1,
            'pv2_voltage': vc_regs[1] * 0.1,
            'pv1_current': vc_regs[2] * 0.1,
            'pv2_current': vc_regs[3] * 0.1,
            'pv1_power': power_regs[0],
            'pv2_power': power_regs[1],
        }
    
    def _process_battery_data(self, regs: list) -> Dict[str, Any]:
        """Process battery system data."""
        return {
            'battery_voltage': self._to_signed(regs[0]) * 0.1,
            'battery_current': self._to_signed(regs[1]) * 0.1,
            'battery_power': self._to_signed(regs[2]),
            'battery_temperature': self._to_signed(regs[4]),
            'battery_soc': regs[8],
        }
    
    @staticmethod
    def _to_signed(value: int) -> int:
        """Convert unsigned 16-bit to signed 16-bit."""
        return value if value < 32768 else value - 65536
    
    @staticmethod
    def _to_signed_32(low: int, high: int) -> int:
        """Convert two 16-bit registers to signed 32-bit (little endian)."""
        value = (high << 16) | low
        return value if value < 2147483648 else value - 4294967296
    
    @staticmethod
    def _to_unsigned_32(low: int, high: int) -> int:
        """Convert two 16-bit registers to unsigned 32-bit (little endian)."""
        return (high << 16) | low


class InverterDisplay:
    """Handles formatted display of inverter statistics."""
    
    @staticmethod
    def display_statistics(data: Dict[str, Any]):
        """
        Format and display statistics to console.
        
        Args:
            data: Dictionary of inverter metrics
        """
        if not data:
            print("No data available")
            return
        
        print("\n" + "=" * 70)
        print("Solax X3 Hybrid 6.0-D Inverter Statistics")
        print(f"Timestamp: {data.get('timestamp', 'N/A')}")
        print("=" * 70)
        
        # System status
        if 'run_mode' in data:
            print(f"\nâš¡ System Status: {data['run_mode']}")
        
        # Grid information
        print("\nðŸ“Š Grid (Three-Phase AC)")
        print("-" * 70)
        if 'grid_voltage_r' in data:
            print(f"  R Phase: {data['grid_voltage_r']:6.1f}V  "
                  f"{data.get('grid_current_r', 0):6.1f}A  "
                  f"{data.get('grid_power_r', 0):7.0f}W")
            print(f"  S Phase: {data['grid_voltage_s']:6.1f}V  "
                  f"{data.get('grid_current_s', 0):6.1f}A  "
                  f"{data.get('grid_power_s', 0):7.0f}W")
            print(f"  T Phase: {data['grid_voltage_t']:6.1f}V  "
                  f"{data.get('grid_current_t', 0):6.1f}A  "
                  f"{data.get('grid_power_t', 0):7.0f}W")
            
            total_power = (
                data.get('grid_power_r', 0) + 
                data.get('grid_power_s', 0) + 
                data.get('grid_power_t', 0)
            )
            print(f"  Total:   {total_power:7.0f}W")
            print(f"  Frequency: {data.get('grid_frequency_r', 0):.2f}Hz")
        
        # Solar PV information
        print("\nâ˜€ï¸  Solar PV Generation")
        print("-" * 70)
        if 'pv1_voltage' in data:
            print(f"  PV1: {data['pv1_voltage']:6.1f}V  "
                  f"{data.get('pv1_current', 0):5.1f}A  "
                  f"{data.get('pv1_power', 0):6.0f}W")
            print(f"  PV2: {data['pv2_voltage']:6.1f}V  "
                  f"{data.get('pv2_current', 0):5.1f}A  "
                  f"{data.get('pv2_power', 0):6.0f}W")
            
            total_pv = data.get('pv1_power', 0) + data.get('pv2_power', 0)
            print(f"  Total: {total_pv:6.0f}W")
        
        # Battery information
        print("\nðŸ”‹ Battery System")
        print("-" * 70)
        if 'battery_voltage' in data:
            print(f"  Voltage: {data['battery_voltage']:.1f}V")
            
            current = data.get('battery_current', 0)
            if current > 0:
                direction = "Charging"
            elif current < 0:
                direction = "Discharging"
            else:
                direction = "Idle"
            print(f"  Current: {abs(current):.1f}A ({direction})")
            print(f"  Power: {data.get('battery_power', 0):.0f}W")
            print(f"  State of Charge: {data.get('battery_soc', 0)}%")
            print(f"  Temperature: {data.get('battery_temperature', 0)}Â°C")
        
        # Power flow
        print("\nâš¡ Power Flow")
        print("-" * 70)
        if 'feed_in_power' in data:
            feedin = data['feed_in_power']
            if feedin > 0:
                print(f"  Grid Status: EXPORTING {feedin}W")
            elif feedin < 0:
                print(f"  Grid Status: IMPORTING {abs(feedin)}W")
            else:
                print(f"  Grid Status: BALANCED (0W)")
        
        # Energy accounting
        print("\nðŸ“ˆ Energy Totals")
        print("-" * 70)
        if 'energy_today' in data:
            print(f"  Solar Generation Today: {data['energy_today']:.1f}kWh")
        if 'energy_total' in data:
            print(f"  Total Generation: {data['energy_total']:.1f}kWh")
        
        # Inverter status
        print("\nðŸ”§ Inverter")
        print("-" * 70)
        if 'inverter_temperature' in data:
            print(f"  Temperature: {data['inverter_temperature']}Â°C")
        
        print("=" * 70 + "\n")


def main():
    """Main execution loop with argument parsing and error handling."""
    
    # Parse command line arguments
    parser = argparse.ArgumentParser(
        description='Solax X3 Hybrid 6.0-D Inverter Monitoring via Modbus TCP',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s 192.168.1.100              # Monitor with 5-second interval
  %(prog)s 192.168.1.100 --interval 10   # Monitor with 10-second interval
  %(prog)s 192.168.1.100 --port 1502     # Use non-standard port
  %(prog)s 192.168.1.100 --debug         # Enable debug logging
        """
    )
    
    parser.add_argument(
        'ip',
        help='IP address of the inverter (WiFi/LAN dongle)'
    )
    parser.add_argument(
        '--port',
        type=int,
        default=502,
        help='Modbus TCP port (default: 502)'
    )
    parser.add_argument(
        '--unit-id',
        type=int,
        default=1,
        help='Modbus unit ID (default: 1)'
    )
    parser.add_argument(
        '--interval',
        type=int,
        default=5,
        help='Polling interval in seconds (minimum: 1, default: 5)'
    )
    parser.add_argument(
        '--debug',
        action='store_true',
        help='Enable debug logging'
    )
    
    args = parser.parse_args()
    
    # Configure logging level
    if args.debug:
        logging.getLogger().setLevel(logging.DEBUG)
    
    # Validate polling interval
    poll_interval = max(args.interval, 1)
    if args.interval < 1:
        logger.warning(f"Interval {args.interval}s below minimum, using 1s")
    
    # Print startup information
    print(f"\nSolax X3 Hybrid Inverter - Modbus TCP Monitor")
    print(f"Connecting to {args.ip}:{args.port}")
    print(f"Polling interval: {poll_interval} seconds")
    print(f"Press Ctrl+C to stop\n")
    print("-" * 70)
    
    # Initialize client and display
    client = SolaxInverterClient(args.ip, args.port, args.unit_id)
    display = InverterDisplay()
    
    # Main monitoring loop
    try:
        while True:
            try:
                # Connect if not connected
                if not client.client or not client.client.is_socket_open():
                    if not client.connect():
                        logger.error("Failed to establish connection, retrying...")
                        time.sleep(poll_interval)
                        continue
                
                # Poll and display data
                data = client.poll_inverter()
                display.display_statistics(data)
                
                # Wait for next poll
                time.sleep(poll_interval)
                
            except KeyboardInterrupt:
                raise  # Re-raise to exit cleanly
            except Exception as e:
                logger.error(f"Error in monitoring loop: {e}", exc_info=True)
                time.sleep(poll_interval)
                
    except KeyboardInterrupt:
        print("\n\nâš ï¸  Shutdown signal received...")
    finally:
        client.disconnect()
        print("âœ… Monitoring stopped")
        logger.info("Application terminated")


if __name__ == "__main__":
    main()
